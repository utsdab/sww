# -----------------------------------------------------------------------------
#
# Copyright (c) 1986-2018 Pixar. All rights reserved.
#
# The information in this file (the "Software") is provided for the exclusive
# use of the software licensees of Pixar ("Licensees").  Licensees have the
# right to incorporate the Software into other products for use by other
# authorized software licensees of Pixar, without fee. Except as expressly
# permitted herein, the Software may not be disclosed to third parties, copied
# or duplicated in any form, in whole or in part, without the prior written
# permission of Pixar.
#
# The copyright notices in the Software and this entire statement, including the
# above license grant, this restriction and the following disclaimer, must be
# included in all copies of the Software, in whole or in part, and all permitted
# derivative works of the Software, unless such copies or derivative works are
# solely in the form of machine-executable object code generated by a source
# language processor.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL PIXAR BE
# LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
# OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  IN NO CASE WILL
# PIXAR'S TOTAL LIABILITY FOR ALL DAMAGES ARISING OUT OF OR IN CONNECTION WITH
# THE USE OR PERFORMANCE OF THIS SOFTWARE EXCEED $50.
#
# Pixar
# 1200 Park Ave
# Emeryville CA 94608
#
# -----------------------------------------------------------------------------

# pylint: disable=import-error
import subprocess
import maya.mel as mel
import maya.cmds as mc
from rfm2.config import cfg, RfmError
from rfm2.config import DEFAULT_DISPLAY_NAME, DEFAULT_DISPLAY_NODE
import rfm2.api.strings as apistr
import rfm2.api.displays as apidspy
import rfm2.api.nodes as apinodes
import rfm2.spool.utils as sputils
import rfm2.render
from rfm2 import rfm_log, render_with_renderman
import rfm2.ui.prefs
from rfm2.utils.filepath import FilePath
import rfm2.txmanager_maya as txmgr_maya
import txmanager as txmgr
from maya import utils as mutils

import os
import os.path
import tractor.api.author as author
import getpass
import socket
import time
import datetime
from collections import OrderedDict


def add_prman_render_task(parentTask, title, threads, rib, img, args=[]):
    """Create a single prman task for a Tractor job.

    Args:
    - parentTask (Task) - parent task that this prman task belongs to.
    - title (str) - title to use for this task.
    - threads (int) - number of threads to use for this prman task.
    - rib (str) - full path to the RIB file to render.
    - img (str) - full path to the image file that will be generated by the
                  prman task. This is used to create the preview/chaser task.
    - args (list) - other args to pass to prman
    """

    task = author.Task()
    task.title = title
    if img:
        task.preview = 'sho %s' % str(img)

    command = author.Command(local=False, service="PixarRender")
    command.argv = ["prman"]
    for arg in args:
        command.argv.append(arg)

    for arg in ["-Progress", "-t:%d" % threads, "%%D(%s)" % rib]:
        command.argv.append(arg)

    task.addCommand(command)
    parentTask.addChild(task)


def add_maya_batch_render_task(parentTask, title, stash_scene_name, imgs,
                               is_anim, start, end, by, args=[]):
    """Create a single Maya Render task for a Tractor job.

    Args:
    - parentTask (Task) - parent task that this Maya Render task belongs to.
    - title (str) - title to use for this task.
    - stash_scene_name (str) - full path to the scene file name.
    - imgs (list) - list of full path image files to create the preview/chaser task.
                    only for single frame renders i.e.: start==end
    - is_anim (bool) - emit start, end, by args to the batch render command
    - start (int) - the start frame for an animation sequence.
    - end (int) - the end frame for an animation sequence.
    - by (int) - by frame (or step) for an animation sequence.
    - args (list) - other args to pass to maya batch
    """

    task = author.Task()
    task.title = title
    if start == end:
        if len(imgs) > 0:
            sho_cmd = 'sho '
            for img in imgs:
                sho_cmd = sho_cmd + '%s ' % str(img)
            task.preview = sho_cmd

    command = author.Command(local=False, service="PixarRender")
    proj = mc.workspace(q=True, rd=True)

    rendercmd = "Render"
    command.argv = [rendercmd, "-r", "renderman", "-proj", "%%D(%s)" % proj]
    for arg in args:
        command.argv.append(arg)

    if is_anim:
        command.argv.append("-s")
        command.argv.append(start)
        command.argv.append("-e")
        command.argv.append(end)
        command.argv.append("-b")
        command.argv.append(by)

    command.argv.append("%%D(%s)" % stash_scene_name)

    task.addCommand(command)
    parentTask.addChild(task)


def add_txmake_task(parentTask, title, args):
    """Create a single txmake task for Tractor job.

    Args:
    - parentTask (Task) - parent task that this txmake task belongs to.
    - title (str) - title to use for this task.
    - args (list) - txmake args including input and output name

    """
    task = author.Task()
    task.title = title

    command = author.Command(local=False, service="PixarRender")
    argv = ['txmake'] + args
    command.argv = argv

    task.addCommand(command)
    parentTask.addChild(task)


def add_denoise_task(parentTask, title, args, imgs, preview_imgs=[],
                     variance_files=[]):
    """Create a single denoise task for Tractor job.

    Args:
    - parentTask (Task) - parent task that this denoise task belongs to.
    - title (str) - title to use for this task.
    - args (list) - arguments to denoiser
    - imgs (list) - list of images to be denoised
    - preview_imgs (list) - list of images to generate preview tasks
    - variance_files (list) - list of variance files

    """
    if not rfm2.ui.prefs.get_pref_by_name('rfmRenderBatchLaunchDenoiser'):
        return

    task = author.Task()
    task.title = title

    command = author.Command(local=False, service="PixarRender")
    command.argv = ["denoise"]
    for arg in args:
        command.argv.append(arg)
    for f in variance_files:
        command.argv.append("%%D(%s)" % f)

    for f in imgs:
        command.argv.append("%%D(%s)" % f)

    if preview_imgs:
        imgs = " ".join(str(x) for x in preview_imgs)
        task.preview = 'sho %s' % str(imgs)

    task.addCommand(command)
    parentTask.addChild(task)


def get_denoise_filtered_name(s):
    """Try to ascertain what the filtered version of
    the image filename will be after it has been denoised.

    Args:
    - s (str) - path to tokenized filename
    """

    import re

    dirname = os.path.dirname(s)
    basename = os.path.basename(s)

    # place _filtered right before frame number. Account for the following
    # cases:
    #   /path/to/image.exr       ->  /path/to/image_filtered.exr
    #   /path/to/image.<f4>.exr  ->  /path/to/image_filtered.<f4>.exr
    #   /path/to/image.0034.exr  ->  /path/to/image_filtered.0034.exr
    rs = re.compile(r'(\.)([\w<>]+\.\w+|\w+)')
    filtered = re.sub(rs, r'_filtered.\g<2>', basename)

    return "%s/%s" % (dirname, filtered)


def generate_denoise_tasks(frametasktitle, frametask, displays, frame,
                           start=1, end=1, by=1):
    """Create denoise tasks for a single frame for a Tractor job

    Args:
    - frametasktitle
    - frametask (Task) - parent task that these denoise tasks belongs to.
    - displays (dict) - displays dict
    - frame (int) - the current frame
    - start (int) - the starting frame of the sequence
    - end (int) - the end frame of the sequence
    - by (int) - how many frames to skip

    """

    DENOISE_SINGLE_FRAME = 0
    DENOISE_CROSSFRAME = 1

    # look for the variance file
    variance_file = None
    variance_display = None
    denoiseAOVs = False
    denoise_displays = {}
    for d in displays:
        if d.endswith('variance'):
            filepath = displays[d]['filePath']
            variance_display = d
            variance_file = filepath
            denoise_displays[d] = displays[d]
        else:
            dspy_node = d
            if dspy_node == DEFAULT_DISPLAY_NAME:
                # skip beauty
                continue
            if mc.objExists(dspy_node) is False:
                # this might be an 'it' splitted display
                continue
            mode = mc.getAttr('%s.denoise' % dspy_node)
            if mode == 1:
                denoiseAOVs = True
                denoise_displays[d] = displays[d]

    if denoiseAOVs and not variance_display:
        rfm_log().warning('At least one AOV has requested denoise, but could '
                          'not find a variance display. No denoise tasks added.')
        return

    if variance_display:
        for d in denoise_displays:
            is_variance = False
            filepath = denoise_displays[d]['filePath']
            imgfile = FilePath(apistr.expand_string(filepath, display=d,
                                                    frame=frame))
            dspy_node = d
            if variance_display == d:
                is_variance = True
            dspy_node = dspy_node.replace('_variance', '')
            if dspy_node == DEFAULT_DISPLAY_NAME:
                dspy_node = DEFAULT_DISPLAY_NODE
            base_args = []
            mode = mc.getAttr('%s.denoise' % dspy_node)
            frameMode = mc.getAttr('%s.frameMode' % dspy_node)

            if mode:
                denoise_task_title = ("%s Image: %s (denoise)" %
                                      (frametasktitle,
                                       str(os.path.basename(imgfile))))
                if frameMode == DENOISE_SINGLE_FRAME:
                    if is_variance:
                        args = base_args
                        preview_img = imgfile.replace('_variance', '_filtered')
                        add_denoise_task(frametask, denoise_task_title, args,
                                         [imgfile], [preview_img])

                    else:
                        args = base_args
                        variance_file_expand = FilePath(apistr.expand_string(
                            variance_file, display=variance_display, frame=frame))
                        filtered_path = get_denoise_filtered_name(filepath)
                        filtered_path_expand = FilePath(apistr.expand_string(
                            filtered_path, display=d, frame=frame))
                        add_denoise_task(frametask, denoise_task_title, args,
                                         [imgfile], [filtered_path_expand],
                                         [variance_file_expand])

                elif frameMode == DENOISE_CROSSFRAME:
                    if (start == end) or ( (start+1) == end) or (by > 1):
                        # Treat as if single frame denoise in these cases
                        #
                        # - we are rendering only 1 or 2 frames
                        # - by set to greater than 1
                        if is_variance:
                            args = base_args
                            preview_img = imgfile.replace('_variance', '_filtered')
                            add_denoise_task(frametask, denoise_task_title, args,
                                             [imgfile], [preview_img])

                        else:
                            args = base_args
                            variance_file_expand = FilePath(apistr.expand_string(
                                variance_file, display=variance_display, frame=frame))
                            filtered_path = get_denoise_filtered_name(filepath)
                            filtered_path_expand = FilePath(apistr.expand_string(
                                filtered_path, display=d, frame=frame))
                            add_denoise_task(frametask, denoise_task_title, args,
                                             [imgfile], [filtered_path_expand],
                                             [variance_file_expand])

                    else:
                        base_args.append("--crossframe")
                        base_args.append("-v")
                        base_args.append("variance")

                        f1 = FilePath(apistr.expand_string(variance_file,
                                                           display=variance_display,
                                                           frame=frame-2))
                        f2 = FilePath(apistr.expand_string(variance_file,
                                                           display=variance_display,
                                                           frame=frame-1))
                        f3 = FilePath(apistr.expand_string(variance_file,
                                                           display=variance_display,
                                                           frame=frame))
                        variance_files = [f1, f2, f3]

                        f1 = FilePath(apistr.expand_string(filepath,
                                                           display=d,
                                                           frame=frame-2))
                        f2 = FilePath(apistr.expand_string(filepath,
                                                           display=d,
                                                           frame=frame-1))
                        f3 = FilePath(apistr.expand_string(filepath,
                                                           display=d,
                                                           frame=frame))
                        imgs = [f1, f2, f3]

                        filtered_path = get_denoise_filtered_name(filepath)
                        p0 = FilePath(apistr.expand_string(filepath,
                                                           display=d,
                                                           frame=frame-2))
                        p1 = FilePath(apistr.expand_string(filepath,
                                                           display=d,
                                                           frame=frame-1))
                        p2 = FilePath(apistr.expand_string(filepath,
                                                           display=d,
                                                           frame=frame))

                        if (frame - 2) == start:
                            # we need at least three frames to do crossframe
                            # check if we're on the first three
                            # doing only --skiplast will take care of the first
                            # two frames.
                            args = [i for i in base_args]

                            if frame != end:
                                # only add --skiplast if we're in a sequence
                                # that is longer than three frames. If we're on
                                # a three-frame sequence just denoise all three
                                # frames in one denoise task, otherwise
                                # the second frame will get denoise twice.
                                args.append("--skiplast")

                            if is_variance:
                                p0 = variance_files[0]
                                p1 = variance_files[1]
                                p0 = p0.replace('_variance', '_filtered')
                                p1 = p1.replace('_variance', '_filtered')
                                add_denoise_task(frametask, denoise_task_title,
                                                 args, variance_files, [p0, p1])
                            else:
                                add_denoise_task(frametask, denoise_task_title,
                                                 args, imgs, [p0, p1], variance_files)

                            if frame == end:
                                # this is just a three-frame sequence. See
                                # comment above.
                                return

                        if (frame - 2) > start and frame < end:
                            # if we're past the first three, but the current frame
                            # is less than the end frame
                            args = [i for i in base_args]
                            args.append("--skipfirst")
                            args.append("--skiplast")

                            if is_variance:
                                p1 = variance_files[1]
                                p1 = p1.replace('_variance', '_filtered')
                                add_denoise_task(frametask, denoise_task_title,
                                                 args, variance_files, [p1])
                            else:
                                add_denoise_task(frametask, denoise_task_title,
                                                 args, imgs, [p1], variance_files)

                        if frame == end:
                            # if we're on the last frame, doing just --skipfirst
                            # will take care of the last and second last
                            # frames.
                            args = [i for i in base_args]
                            args.append("--skipfirst")

                            if is_variance:
                                p1 = variance_files[1]
                                p2 = variance_files[2]
                                p1 = p1.replace('_variance', '_filtered')
                                p2 = p2.replace('_variance', '_filtered')
                                add_denoise_task(frametask, denoise_task_title,
                                                 args, variance_files, [p1, p2])
                            else:
                                add_denoise_task(frametask, denoise_task_title,
                                                 args, imgs, [p1, p2], variance_files)


def generate_txmake_tasks():
    """Generate txmake tasks to be added to a job file

    Returns
        - txmakeParentTask (Task): the parent task of all the txmake tasks
    """

    txmakeParentTask = author.Task()
    txmakeParentTask.title = 'Pre-Render TxMake Tasks'
    txmakeParentTask.serialsubtasks = False

    # Ask the texture manager to stop the queue and return a list of remaining
    # tasks.
    for task in txmgr_maya.stop_and_return_remaining_task():
        argv = task['args']
        argv.append('-newer')
        argv.append('%%D(%s)' % str(task['infile']))
        argv.append('%%D(%s)' % str(task['outfile']))
        txmaketasktitle = 'TxMake: %s' % (str(task['infile']))
        add_txmake_task(txmakeParentTask, txmaketasktitle, argv)

    return txmakeParentTask


def add_job_level_attrs(is_localqueue, job):

    rmanversion = cfg().rfm_env['versions']['rfm']

    paused = rfm2.ui.prefs.get_pref_by_name('rfmTractorPaused')
    priority = str(rfm2.ui.prefs.get_pref_by_name('rfmTractorPriority'))
    service = str(rfm2.ui.prefs.get_pref_by_name('rfmTractorService'))
    envkey = str(rfm2.ui.prefs.get_pref_by_name('rfmTractorEnvKey'))
    crews = str(rfm2.ui.prefs.get_pref_by_name('rfmTractorCrews'))
    tier = str(rfm2.ui.prefs.get_pref_by_name('rfmTractorTier'))
    projects = str(rfm2.ui.prefs.get_pref_by_name('rfmTractorProjects'))
    comment = str(rfm2.ui.prefs.get_pref_by_name('rfmTractorComment'))
    metadata = str(rfm2.ui.prefs.get_pref_by_name('rfmTractorMetaData'))
    whendone = str(rfm2.ui.prefs.get_pref_by_name('rfmTractorWhenDone'))
    whenerror = str(rfm2.ui.prefs.get_pref_by_name('rfmTractorWhenError'))
    whenalways = str(rfm2.ui.prefs.get_pref_by_name('rfmTractorWhenAlways'))
    after = str(rfm2.ui.prefs.get_pref_by_name('rfmTractorAfter'))

    if cfg().dirmaps:
        for k in cfg().dirmaps:
            dirmap = cfg().dirmaps[k]
            job.newDirMap(src=str(dirmap['from']),
                          dst=str(dirmap['to']),
                          zone=str(dirmap['zone']))

    if paused == 1:
        job.paused = True
    if priority != '':
        job.priority = float(priority)
    if service != '':
        job.service = service
    if crews != '':
        job.crews = crews.split()
    if projects != '':
        job.projects = projects.split()
    if comment != '':
        job.comment = comment
    if metadata != '':
        job.metadata = metadata
    if whendone != '':
        job.newPostscript(argv=whendone, when="done", service=service)
    if whenerror != '':
        job.newPostscript(argv=whenerror, when="error", service=service)
    if whenalways != '':
        job.newPostscript(argv=whenalways, when="always", service=service)
    if after != '':
        try:
            aftersplit = after.split(' ')
            if len(aftersplit) == 2:
                t_date = aftersplit[0].split('/')
                t_time = aftersplit[1].split(':')
                if len(t_date) == 2 and len(t_time) == 2:
                    today = datetime.datetime.today()
                    job.after = datetime.datetime(today.year, int(t_date[0]),
                                                  int(t_date[1]),
                                                  int(t_time[0]),
                                                  int(t_time[1]), 0)
                else:
                    rfm_log().warning('Could not parse after date: %s. '
                                      'Ignoring.', after)
            else:
                rfm_log().warning('Could not parse after date: %s. Ignoring.',
                                  after)
        except:
            rfm_log().warning('Could not parse after date: %s. Ignoring.',
                              after)

    rfmenvkey = 'rfm-%s' % (str(rmanversion).strip())
    mayaenvkey = 'maya-%s' % (str(rfm2.render.MAYA_VERSION_STR).strip())
    job.envkey = []
    if not is_localqueue:
        # only add envkeys for Tractor jobs
        if len(envkey) > 0:
            userenvkeys = envkey.split(' ')
            for i, k in enumerate(userenvkeys):
                userenvkeys[i] = os.path.expandvars(k)
            job.envkey.extend(userenvkeys)
        else:
            job.envkey = [rfmenvkey, mayaenvkey]


def create_output_directories(displays, ribdir, imgdir):
    """Take care of creating AOV subdirectories if necessary

    Arguments:
        ribdir {str} -- RIB output path
        imgdir {str} -- image output path
    """
    mc.sysFile(apistr.expand_string(ribdir), makeDir=True)
    if '<aov>' in imgdir:
        for dspy in displays:
            mc.sysFile(apistr.expand_string(imgdir, display=dspy), makeDir=True)
    else:
        mc.sysFile(apistr.expand_string(imgdir), makeDir=True)


def _eval_maya_callback(attr):
    """evaluate a standard callback string. The text will go through our string
    substitution mecanism.

    Arguments:
        attr {str} -- attribute name like 'preMel'
    """
    mel = apistr.get_str_attr('defaultRenderGlobals.%s' % attr)
    if mel and len(mel) > 0:
        mel.eval(mel)


def _add_checkpoint_args(checkpoint_str, args):
    if checkpoint_str != '':
        args.append('-checkpoint')
        args.append(checkpoint_str)
        args.append('-recover')
        args.append('%r')


def _it_setup_succeeded(img_expanded, is_localqueue, args):
    if os.path.splitext(img_expanded)[1] == '.it':
        if is_localqueue:
            args.append('-dspyserver')
            if mc.about(mac=True):
                args.append('$RMANTREE/bin/it.app/Contents/MacOS/it')
            else:
                args.append('it')
        else:
            rfm2.render.show_it()
        return True
    return False


def _preview_img_full_path(beauty_dspy_variance, imgOutputDir, imgFileFormat,
                           **kwargs):
    if beauty_dspy_variance:
        img_expanded = FilePath(apistr.expand_string(
            FilePath(imgOutputDir).join(imgFileFormat),
            display=beauty_dspy_variance, **kwargs))
    else:
        img_expanded = FilePath(apistr.expand_string(
            FilePath(imgOutputDir).join(imgFileFormat), **kwargs))
    return img_expanded


def generate_rib_render_tasks(is_localqueue, anim, parent_task, tasktitle, aovs,
                              beauty_dspy_variance, start, last, by, chunk, threads,
                              do_bake, checkpoint):
    displays = aovs['displays']
    rmanGlobals = apinodes.rman_globals()
    ribOutputDir = mc.getAttr('%s.ribOutputDir' % rmanGlobals)
    imgOutputDir = mc.getAttr('%s.imageOutputDir' % rmanGlobals)
    imgFileFormat = mc.getAttr('%s.imageFileFormat' % rmanGlobals)
    ribFileFormat = mc.getAttr('%s.ribFileFormat' % rmanGlobals)

    ribFilename = ribFileFormat
    ribFullPath = FilePath(ribOutputDir).join(ribFilename)
    create_output_directories(displays, ribOutputDir, imgOutputDir)
    # For spooled rib renders we are responsible for iterating render layers
    # For mayabatch, maya takes care of iterating the render layers.
    renderLayers = mc.listConnections('renderLayerManager.renderLayerId')
    renderLayers = sorted(renderLayers)
    curLayer = mel.eval("editRenderLayerGlobals -q -currentRenderLayer")
    cameras = mc.ls(type='camera')
    doExpandEnvVars = is_localqueue
    foundRenderableCam = False
    bakeFlag = ""
    if do_bake:
        bakeFlag = "-bake"

    # call maya's preMel script
    _eval_maya_callback('preMel')

    for layer in renderLayers:
        renderable = mc.getAttr("%s.renderable" % layer)
        if not renderable:
            continue
        # switch to layer, to cause layer overrides to kick in before
        # ribgen
        mel.eval("editRenderLayerGlobals -currentRenderLayer %s" % layer)

        # call maya's pre render layer script
        _eval_maya_callback('preRenderLayerMel')

        org_val = apistr.get_var('camera')
        for cam in cameras:
            rendercam = mc.getAttr("%s.renderable" % cam)
            if not rendercam:
                continue
            foundRenderableCam = True
            apistr.set_var('camera', cam)
            if anim is False:
                mel.eval('rmanRender "-ribFile \\\"%s\\\" -layer %s -camera %s '
                         '-ribFormat \\\"binary\\\" -expandEnvVars %d %s '
                         '-s %s -e %s -b %s"'  %
                         (ribFullPath, layer, cam, doExpandEnvVars, bakeFlag,
                          start, last, by))
                rib_expanded = FilePath(
                    apistr.expand_string(ribFullPath))
                img_expanded = _preview_img_full_path(beauty_dspy_variance,
                                                      imgOutputDir,
                                                      imgFileFormat)

                frametasktitle = ("%s Frame: %d Layer: %s Camera: %s" %
                                  (tasktitle, int(start), str(layer), str(cam)))
                frametask = author.Task()
                frametask.title = frametasktitle
                frametask.serialsubtasks = True

                prmantasktitle = "%s (render)" % frametasktitle
                args = []

                _add_checkpoint_args(checkpoint, args)

                if _it_setup_succeeded(img_expanded, is_localqueue, args):
                    add_prman_render_task(frametask, prmantasktitle, threads,
                                          rib_expanded, '', args)
                else:
                    add_prman_render_task(frametask, prmantasktitle, threads,
                                          rib_expanded, img_expanded, args)
                    if not do_bake:
                        generate_denoise_tasks(frametasktitle, frametask,
                                               displays, start)

                parent_task.addChild(frametask)

            else:
                curFrame = mc.currentTime(query=True)
                parent_task.serialsubtasks = True
                mel.eval('rmanRender "-ribFile \\\"%s\\\" -layer %s -camera %s '
                         '-ribFormat \\\"binary\\\" -expandEnvVars %d %s '
                         '-s %s -e %s -b %s"' %
                         (ribFullPath, layer, cam, doExpandEnvVars, bakeFlag,
                          start, last, by))

                renderframestask = author.Task()
                renderframestask.serialsubtasks = False
                renderframestasktitle = ("Render Layer: %s Camera: %s" %
                                         (str(layer), str(cam)))
                renderframestask.title = renderframestasktitle

                for iframe in range(int(start), int(last + 1), int(by)):
                    mc.currentTime(iframe)
                    rib_expanded = FilePath(
                        apistr.expand_string(ribFullPath))
                    img_expanded = _preview_img_full_path(beauty_dspy_variance,
                                                          imgOutputDir,
                                                          imgFileFormat)

                    prmantasktitle = ("%s Frame: %d Layer: %s Camera: %s (prman)" %
                                      (tasktitle, int(start), str(layer), str(cam)))
                    args = []

                    _add_checkpoint_args(checkpoint, args)

                    if _it_setup_succeeded(img_expanded, is_localqueue, args):
                        add_prman_render_task(renderframestask, prmantasktitle, threads,
                                              rib_expanded, '', args)
                    else:
                        add_prman_render_task(renderframestask, prmantasktitle, threads,
                                              rib_expanded, img_expanded, args)

                parent_task.addChild(renderframestask)

                if not do_bake:
                    denoiseframestask = author.Task()
                    denoiseframestask.serialsubtasks = False
                    denoiseframestasktitle = ("Denoise Layer: %s Camera: %s" %
                                              (str(layer), str(cam)))
                    denoiseframestask.title = denoiseframestasktitle

                    for iframe in range(int(start), int(last + 1), int(by)):
                        img_expanded = _preview_img_full_path(
                            beauty_dspy_variance, imgOutputDir, imgFileFormat,
                            frame=iframe)

                        denoisetasktitle = ("Denoise Frame: %d Layer: %s Camera: %s" %
                                            (int(start), str(layer), str(cam)))

                        generate_denoise_tasks(denoisetasktitle, denoiseframestask,
                                               displays, iframe, start=int(start),
                                               end=int(last), by=int(by))

                    parent_task.addChild(denoiseframestask)

                mc.currentTime(curFrame)
        # call maya's post render layer script
        _eval_maya_callback('postRenderLayerMel')

    apistr.set_var('camera', org_val)

    # call maya's postMel script
    _eval_maya_callback('postMel')

    # restore original render layer
    mel.eval("editRenderLayerGlobals -currentRenderLayer %s" % layer)
    if not foundRenderableCam:
        raise RfmError('No renderable cameras were found!')


def generate_maya_batch_render_tasks(stash_scene_name, anim, parent_task, tasktitle,
                                     displays, beauty_dspy_variance, start, last,
                                     by, chunk, threads, do_bake, checkpoint):

    rmanGlobals = apinodes.rman_globals()
    imgOutputDir = mc.getAttr('%s.imageOutputDir' % rmanGlobals)
    imgFileFormat = mc.getAttr('%s.imageFileFormat' % rmanGlobals)
    cameras = mc.ls(type='camera')

    args = ['-t', '%d' % threads]
    # jobid has been locked and should always be valid at this point.
    jobid = mc.getAttr('%s.jobid' % rmanGlobals)
    if jobid:
        args += ['-jobid', jobid]
    if do_bake:
        args.append('-bake')
    if checkpoint != '':
        args.append('-checkpoint')
        args.append(checkpoint)

    if mc.about(api=True) >= 20180300 and mc.optionVar(q="renderSetupEnable"):
        args.append('-rst')
        args.append(stash_scene_name + ".json")

    if anim is False:
        frametasktitle = "%s Frame: %d" % (tasktitle, int(start))

        frametask = author.Task()
        frametask.title = frametasktitle
        frametask.serialsubtasks = True

        imgs = []
        org_val = apistr.get_var('camera')
        for cam in cameras:
            rendercam = mc.getAttr("%s.renderable" % cam)
            if not rendercam:
                continue
            apistr.set_var('camera', cam)
            if beauty_dspy_variance:
                img_expanded = FilePath(apistr.expand_string(
                    FilePath(imgOutputDir).join(imgFileFormat),
                    display=beauty_dspy_variance))
            else:
                img_expanded = FilePath(apistr.expand_string(
                    FilePath(imgOutputDir).join(imgFileFormat)))

            imgs.append(img_expanded)

        mayabatch_tasktitle = "%s (mayabatch render)" % frametasktitle
        add_maya_batch_render_task(frametask, mayabatch_tasktitle, stash_scene_name,
                                   imgs, anim, start, start, by, args)

        if not do_bake:
            for cam in cameras:
                rendercam = mc.getAttr("%s.renderable" % cam)
                if not rendercam:
                    continue
                apistr.set_var('camera', cam)
                generate_denoise_tasks(frametasktitle, frametask, displays, start)

        apistr.set_var('camera', org_val)
        parent_task.addChild(frametask)

    else:
        parent_task.serialsubtasks = True
        renderframestask = author.Task()
        renderframestask.serialsubtasks = False
        renderframestasktitle = ("Render Frames")
        renderframestask.title = renderframestasktitle

        for iframe in range(int(start), last + 1, int(chunk * by)):
            e = iframe + (chunk * by) - by
            if e > last:
                e = last

            mayabatch_tasktitle = ("%s Frames: (%d-%d) (mayabatch render)" %
                                   (tasktitle, int(iframe), int(e)))
            if beauty_dspy_variance:
                img_expanded = FilePath(apistr.expand_string(
                    FilePath(imgOutputDir).join(imgFileFormat),
                    display=beauty_dspy_variance))
            else:
                img_expanded = FilePath(apistr.expand_string(
                    FilePath(imgOutputDir).join(imgFileFormat)))

            add_maya_batch_render_task(renderframestask, mayabatch_tasktitle,
                                       stash_scene_name, [], anim, iframe, e,
                                       by, args)

        parent_task.addChild(renderframestask)

        denoiseframestask = author.Task()
        denoiseframestask.serialsubtasks = False
        denoiseframestasktitle = ("Denoise Frames")
        denoiseframestask.title = denoiseframestasktitle
        if not do_bake:
            org_cam_val = apistr.get_var('camera')
            for iframe in range(int(start), int(last + 1), int(by)):
                for cam in cameras:
                    rendercam = mc.getAttr("%s.renderable" % cam)
                    if not rendercam:
                        continue
                    apistr.set_var('camera', cam)
                    if beauty_dspy_variance:
                        img_expanded = FilePath(apistr.expand_string(
                            FilePath(imgOutputDir).join(imgFileFormat),
                            display=beauty_dspy_variance, frame=iframe))
                    else:
                        img_expanded = FilePath(apistr.expand_string(
                            FilePath(imgOutputDir).join(imgFileFormat),
                            frame=iframe))

                    denoisetasktitle = "Denoise Frame: %d" % (int(start))

                    generate_denoise_tasks(denoisetasktitle, denoiseframestask,
                                           displays, iframe, start=int(start),
                                           end=int(last), by=int(by))
            apistr.set_var('camera', org_cam_val)
            parent_task.addChild(denoiseframestask)


def generate_job_file(is_localqueue, scene, stash_scene_name, do_RIB, do_bake):
    """Generate a job file using the Tractor's Job Author API.

    Args:
    - is_localqueue (bool) - are we generating the job file for LocalQueue or not.
    - scene (str) - the current scene name.
    - stash_scene_name (str) - full path to the unique version of the scene file.
                             See 'stash_scene' function.
    - do_RIB (bool) - controls whether to generate RIB for the scene.
    - do_bake (bool) - controls whether to render using the bake hider,
                    which runs PxrBakeTexture nodes in bake mode.

    Returns:
    - job (Job) - Tractor job instance. See 'Job Author Python API' in the
                  Tractor documentation.
    - jobfile (str) - Full path to the job file on disk.

    """

    job = author.Job()
    job.title = str(scene)
    job.serialsubtasks = True
    add_job_level_attrs(is_localqueue, job)

    anim = mc.getAttr('defaultRenderGlobals.animation')
    start = mc.getAttr('defaultRenderGlobals.startFrame')
    end = mc.getAttr('defaultRenderGlobals.endFrame')
    by = int(mc.getAttr('defaultRenderGlobals.byFrameStep'))
    chunk = rfm2.ui.prefs.get_pref_by_name('rfmRenderBatchFrameChunk')
    do_cleanup = int(rfm2.ui.prefs.get_pref_by_name('rfmTractorCleanup'))

    dspys_asrgba = {}
    checkpoint = str(rfm2.ui.prefs.get_pref_by_name('rfmRenderBatchCheckpoint'))
    # if we're checkpointing, temporarily turn off asrgba for all openexr displays
    if checkpoint:
        for d in mc.ls('d_openexr*'):
            dspys_asrgba[d] = mc.getAttr('%s.asrgba' % d)
            mc.setAttr('%s.asrgba' % d, 0)

    if by == 0:
        by = 1
    if anim is False:
        start = mc.currentTime(query=True)
        end = start
        chunk = 1

    last = int(start)
    if anim is True and (end > start):
        last = int(end)
    else:
        anim = False

    threads = int(rfm2.ui.prefs.get_pref_by_name('rfmBatchThreads'))

    aovs = apidspy.get_displays()
    displays = aovs['displays']
    beauty_dspy_variance = None
    xgen_files = []

    # look for the word 'variance' in list
    # of displays. This is needed for the
    # function '_preview_img_full_path' when generating
    # the preview chaser commands
    for d in displays:
        if d.endswith('variance'):
            beauty_dspy_variance = d
            break

    tasktitle = "Render %s" % (str(scene))
    parent_task = author.Task()
    parent_task.title = tasktitle

    if do_RIB:
        generate_rib_render_tasks(is_localqueue, anim, parent_task, tasktitle,
                                  aovs, beauty_dspy_variance, start, last,
                                  by, chunk, threads, do_bake, checkpoint)
    else:
        # mayabatch
        xgen_files = sputils.stash_xgen_files(stash_scene_name)
        generate_maya_batch_render_tasks(stash_scene_name, anim, parent_task,
                                         tasktitle, displays, beauty_dspy_variance,
                                         start, last, by, chunk, threads,
                                         do_bake, checkpoint)

    # txmake tasks
    txmakeTasks = generate_txmake_tasks()
    job.addChild(txmakeTasks)

    job.addChild(parent_task)
    jobfile = os.path.splitext(stash_scene_name)[0] + '.alf'

    if do_cleanup:
        if do_RIB is False:
            stashCleanup = author.Command(local=False)
            stashCleanup.argv = ["TractorBuiltIn", "File", "delete",
                                 "%%D(%s)" % stash_scene_name]
            job.addCleanup(stashCleanup)
            if mc.about(api=True) >= 20180300 and mc.optionVar(q="renderSetupEnable"):
                stashRSCleanup = author.Command(local=False)
                stashRSCleanup.argv = ["TractorBuiltIn", "File", "delete",
                                       "%%D(%s)" % (stash_scene_name + ".json")]
                job.addCleanup(stashRSCleanup)

        if is_localqueue is False:
            jobFileCleanup = author.Command(local=False)
            jobFileCleanup.argv = ["TractorBuiltIn", "File", "delete",
                                   "%%D(%s)" % jobfile]
            job.addCleanup(jobFileCleanup)

        # clean up for stashed xgen files
        for f in xgen_files:
            xgen_cleanup = author.Command(local=False)
            xgen_cleanup.argv = ["TractorBuiltIn", "File", "delete", "%s" % f]
            job.addCleanup(xgen_cleanup)

    # turn asrgba back
    if checkpoint:
        for k, v in dspys_asrgba.iteritems():
            mc.setAttr('%s.asrgba' % k, v)

    try:
        f = open(jobfile, 'w')
        as_tcl = job.asTcl()
        f.write(as_tcl)
        f.close()
    except IOError as ioe:
        raise RfmError('IO Exception when writing job file %s: %s' % (jobfile, str(ioe)))
    except Exception, e:
        raise RfmError('Could not write job file %s: %s' % (jobfile, str(e)))

    return [job, jobfile]


def batch_render_spool(do_bake=False):
    """Main entry point to start a spooled batch render job. Will spool
    to either LocalQueue or Tractor, depending on the rfmRenderBatchQueue pref.
    """
    spoolstyle = rfm2.ui.prefs.get_pref_by_name('rfmRenderBatchSpoolStyle')
    if spoolstyle == 'RIB' and mel.eval('rman ctxIsOpen'):
        rfm_log().warning("Can't generate rib while rendering")
        return

    # generate a new unique job id and lock it.
    apistr.lock_jobid(None)

    rfm2.render.RNDR.set_render_type(rfm2.render.RT_BATCH)

    # tell texture manager to start parsing scene, before
    # we set up batch rendering
    txmgr_maya.parse_maya_scene()

    stash_scene_name = ''
    is_localqueue = False
    queue = rfm2.ui.prefs.get_pref_by_name('rfmRenderBatchQueue')
    if queue == 'Local Queue':
        is_localqueue = True

    scene_file = mc.file(query=True, sceneName=True)
    if scene_file == '':
        scene_file = 'untitled'
    scene = os.path.basename(scene_file)

    do_RIB = False
    if spoolstyle == 'RIB':
        do_RIB = True
        stash_scene_name = sputils.stash_scene(doSave=False)
    else:
        stash_scene_name = sputils.stash_scene(doSave=True)

    job, jobfile = generate_job_file(is_localqueue, scene, stash_scene_name,
                                     do_RIB, do_bake)

    apistr.unlock_jobid()

    if is_localqueue:
        lq = cfg().renderer_executable('LocalQueue')
        args = []
        args.append(lq)
        args.append(jobfile)
        rfm_log().info('Spooling job to LocalQueue: %s.', jobfile)
        subprocess.Popen(args)
    else:
        # spool to tractor
        tractor_cfg = cfg().tractor_cfg
        tractor_engine = tractor_cfg.get('engine', 'tractor-engine')
        tractor_port = tractor_cfg.get('port', '80')
        owner = tractor_cfg.get('user', getpass.getuser())

        # env var trumps rfm.config
        if 'TRACTOR_ENGINE' in os.environ:
            tractor_env = os.environ['TRACTOR_ENGINE'].split(':')
            tractor_engine = tractor_env[0]
            if len(tractor_env) > 1:
                tractor_port = tractor_env[1]

        if 'TRACTOR_USER' in os.environ:
            owner = os.environ['TRACTOR_USER']

        try:
            spoolhost = socket.gethostname()
            job.spool(block=True, spoolfile=jobfile, spoolhost=spoolhost,
                      owner=owner, hostname=tractor_engine,
                      port=int(tractor_port))
            rfm_log().info('Spooling to Tractor Engine: %s:%s, Job File: %s', tractor_engine,
                           tractor_port, jobfile)
        except author.SpoolError as spoolError:
            mc.sysFile(stash_scene_name, delete=True)
            mc.sysFile(jobfile, delete=True)
            raise RfmError('A communication error has occured with Tractor '
                           'Engine (%s:%s): %s' %
                           (tractor_engine, tractor_port, str(spoolError)))
        except Exception, e:
            mc.sysFile(stash_scene_name, delete=True)
            mc.sysFile(jobfile, delete=True)
            raise RfmError('Unexpected error spooling job file to Tractor '
                           'Engine (%s:%s): %s' %
                           (tractor_engine, tractor_port, str(e)))


def batch_preview():
    """Generate a simple job file
    and spool to LocalQueue, rendering to 'it'
    """
    spoolstyle = rfm2.ui.prefs.get_pref_by_name('rfmRenderBatchSpoolStyle')
    if spoolstyle == 'RIB' and mel.eval('rman ctxIsOpen'):
        rfm_log().warning("Can't generate rib while rendering")
        return

    curLayer = mel.eval("editRenderLayerGlobals -q -currentRenderLayer")
    renderable = mc.getAttr("%s.renderable" % curLayer)
    if not renderable:
        rfm_log().error("Layer: %s is not renderable" % curLayer)
        return

    is_localqueue = False
    queue = rfm2.ui.prefs.get_pref_by_name('rfmRenderBatchQueue')
    if queue == 'Local Queue':
        is_localqueue = True

    render_with_renderman()
    rfm2.render.RNDR.set_render_type(rfm2.render.RT_PREVIEW)

    # turn off animation temporarily
    anim = mc.getAttr('defaultRenderGlobals.animation')
    mc.setAttr('defaultRenderGlobals.animation', 0)

    scene_file = mc.file(query=True, sceneName=True)
    if scene_file == '':
        scene_file = 'untitled'
    scene = os.path.basename(scene_file)

    threads = int(rfm2.ui.prefs.get_pref_by_name('rfmBatchThreads'))

    stash_scene_name = scene
    xgen_files = []
    if spoolstyle != 'RIB':
        stash_scene_name = sputils.stash_scene(doSave=True)
        xgen_files = sputils.stash_xgen_files(stash_scene_name)
    else:
        # just get a name, used to generate job file name
        stash_scene_name = sputils.stash_scene(doSave=False)

    job = author.Job()
    job.title = str(scene)
    job.serialsubtasks = True
    job.service = 'PixarRender'

    tasktitle = "Render %s" % (str(scene))
    parentTask = author.Task()
    parentTask.title = tasktitle

    curFrame = mc.currentTime(query=True)

    frametasktitle = "%s Frame %d" % (tasktitle, int(curFrame))

    frametask = author.Task()
    frametask.title = frametasktitle
    frametask.serialsubtasks = True
    if spoolstyle == 'RIB':
        rmanGlobals = apinodes.rman_globals()
        ribOutputDir = mc.getAttr('%s.ribOutputDir' % rmanGlobals)
        ribFileFormat = mc.getAttr('%s.ribFileFormat' % rmanGlobals)
        ribFullPath = FilePath(ribOutputDir).join(ribFileFormat)
        res = mel.eval('getTestResolution("")')
        mel.eval('rmanRender "-resolution %d %d -ribFile \\\"%s\\\" '
                 '-ribFormat \\\"binary\\\" -expandEnvVars %d"' %
                 (res[0], res[1], ribFullPath, is_localqueue))
        rib_expanded = FilePath(apistr.expand_string(ribFullPath))
        args = ["-d", "it"]
        add_prman_render_task(frametask, "%s (prman)" % frametasktitle, threads,
                              rib_expanded, [], args)
    else:
        mayabatch_tasktitle = "%s (mayabatch render)" % frametasktitle
        args = ["-of", "it", "-t", "%d" % threads]
        add_maya_batch_render_task(frametask, mayabatch_tasktitle, stash_scene_name,
                                [], False, curFrame, curFrame, 1, args)

    parentTask.addChild(frametask)

    # txmake tasks
    txmakeTasks = generate_txmake_tasks()
    job.addChild(txmakeTasks)

    job.addChild(parentTask)

    if spoolstyle != 'RIB':
        stash_cleanup = author.Command(local=False)
        stash_cleanup.argv = ["TractorBuiltIn", "File", "delete", "%s" % stash_scene_name]
        job.addCleanup(stash_cleanup)

        for f in xgen_files:
            xgen_cleanup = author.Command(local=False)
            xgen_cleanup.argv = ["TractorBuiltIn", "File", "delete", "%s" % f]
            job.addCleanup(xgen_cleanup)

    jobfile = os.path.splitext(stash_scene_name)[0] + '.alf'

    try:
        f = open(jobfile, 'w')
        f.write(job.asTcl())
        f.close()
    except IOError as ioe:
        raise RfmError('IO Exception when writing job file %s: %s' % (jobfile, str(ioe)))
    except Exception, e:
        raise RfmError('Could not write job file %s: %s' % (jobfile, str(e)))

    lq = cfg().renderer_executable('LocalQueue')
    args = []
    args.append(lq)
    args.append(jobfile)
    rfm_log().info('Spooling job to LocalQueue: %s.', jobfile)
    subprocess.Popen(args)

    # restore animation setting
    mc.setAttr('defaultRenderGlobals.animation', anim)


def register_tractor_prefs():
    """Register Tractor preferences."""

    import rfm2.utils.node_desc as node_desc
    prefGroup = '0 Render'

    pref = {'name': 'rfmTractorPaused', 'type': 'int',
            'default': 0, 'label': 'Start Paused:',
            'page': 'Render/Batch Render/Tractor', 'widget': 'checkBox',
            'help': ("""Job will be set to paused when spooled.""")}
    rfm2.ui.prefs.register_pref_item(prefGroup,
                                     node_desc.NodeDescParamJSON(pref))

    pref = {'name': 'rfmTractorCleanup', 'type': 'int',
            'default': 1, 'label': 'Delete Temp Files:',
            'page': 'Render/Batch Render/Tractor', 'widget': 'checkBox',
            'help': ("""Job will clean up any temporary files needed for batch rendering.""")}
    rfm2.ui.prefs.register_pref_item(prefGroup,
                                     node_desc.NodeDescParamJSON(pref))

    pref = {'name': 'rfmTractorPriority', 'type': 'int',
            'default': 1, 'label': 'Priority:',
            'page': 'Render/Batch Render/Tractor',
            'page_open': 'false',
            'help': ("""Priority for your job.""")}
    rfm2.ui.prefs.register_pref_item(prefGroup,
                                     node_desc.NodeDescParamJSON(pref))

    pref = {'name': 'rfmTractorService', 'type': 'string',
            'default': 'PixarRender', 'label': 'Service:',
            'page': 'Render/Batch Render/Tractor',
            'help': ("""Service keys for your job.""")}
    rfm2.ui.prefs.register_pref_item(prefGroup,
                                     node_desc.NodeDescParamJSON(pref))

    pref = {'name': 'rfmTractorEnvKey', 'type': 'string',
            'default': '', 'label': 'Env Keys:',
            'page': 'Render/Batch Render/Tractor',
            'help': ("""Multiple keys can be specified and should be space """
                     """separated.<P>
            These environment keys are
            recognized by LocalQueue and Tractor out of box:
            <ul><li>maya-* (eg. maya-2018)
            <li>rfm-* (eg. rfm-22.0)
            <li>rmantree=* (eg. rmantree=$RMANTREE)
            <li>rfmtree=* (eg. rfmtree=$RFMTREE)</ul>""")}
    rfm2.ui.prefs.register_pref_item(prefGroup,
                                     node_desc.NodeDescParamJSON(pref))

    pref = {'name': 'rfmTractorAfter', 'type': 'string',
            'default': '', 'label': 'After:',
            'page': 'Render/Batch Render/Tractor',
            'help': ("""Delay start of job processing until given time<br>
            Format: MONTH/DAY HOUR:MINUTES<br>
            Ex: 11/24 13:45""")}
    rfm2.ui.prefs.register_pref_item(prefGroup,
                                     node_desc.NodeDescParamJSON(pref))

    pref = {'name': 'rfmTractorCrews', 'type': 'string',
            'default': '', 'label': 'Crews:',
            'page': 'Render/Batch Render/Tractor',
            'help': ("""List of crews. See 'Crews' in the Tractor """
                     """documentation.""")}
    rfm2.ui.prefs.register_pref_item(prefGroup,
                                     node_desc.NodeDescParamJSON(pref))

    pref = {'name': 'rfmTractorTier', 'type': 'string',
            'default': '', 'label': 'Tier:',
            'page': 'Render/Batch Render/Tractor',
            'help': ("""Dispatching tier that the job belongs to. See """
                     """'Scheduling Modes' in the Tractor documentation.""")}
    rfm2.ui.prefs.register_pref_item(prefGroup,
                                     node_desc.NodeDescParamJSON(pref))

    pref = {'name': 'rfmTractorProjects', 'type': 'string',
            'default': '', 'label': 'Projects:',
            'page': 'Render/Batch Render/Tractor',
            'help': ("""Project that job belongs to. See 'Limits """
                     """Configuration' in the Tractor documentation.""")}
    rfm2.ui.prefs.register_pref_item(prefGroup,
                                     node_desc.NodeDescParamJSON(pref))

    pref = {'name': 'rfmTractorComment', 'type': 'string',
            'default': '', 'label': 'Comments:',
            'page': 'Render/Batch Render/Tractor',
            'help': ("""Additional comment about the job.""")}
    rfm2.ui.prefs.register_pref_item(prefGroup,
                                     node_desc.NodeDescParamJSON(pref))

    pref = {'name': 'rfmTractorMetaData', 'type': 'string',
            'default': '', 'label': 'Metadata:',
            'page': 'Render/Batch Render/Tractor',
            'help': ("""Meta data to add to the job.""")}
    rfm2.ui.prefs.register_pref_item(prefGroup,
                                     node_desc.NodeDescParamJSON(pref))

    pref = {'name': 'rfmTractorWhenDone', 'type': 'string',
            'default': '', 'label': 'When Done Command:',
            'page': 'Render/Batch Render/Tractor',
            'help': ("""Command to run when job completes withour error.""")}
    rfm2.ui.prefs.register_pref_item(prefGroup,
                                     node_desc.NodeDescParamJSON(pref))

    pref = {'name': 'rfmTractorWhenError', 'type': 'string',
            'default': '', 'label': 'When Error Command:',
            'page': 'Render/Batch Render/Tractor',
            'help': ("""Command to run if there is an error executing """
                     """the job.""")}
    rfm2.ui.prefs.register_pref_item(prefGroup,
                                     node_desc.NodeDescParamJSON(pref))

    pref = {'name': 'rfmTractorWhenAlways', 'type': 'string',
            'default': '', 'label': 'When Always Command:',
            'page': 'Render/Batch Render/Tractor',
            'help': ("""Command to run regardless if job completes with or """
                     """without errors.""")}
    rfm2.ui.prefs.register_pref_item(prefGroup,
                                     node_desc.NodeDescParamJSON(pref))
